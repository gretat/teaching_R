rate.statistics(H,M,C,FA, data)
rate.statistics(H,M,C,FA, x=data)
tidyverse::data_frame()
tidyverse::data.frame()
rate.stat <- function(hits = hits, miss = miss, CorRej = CorRej, falarm = falarm, x = NULL, rm.intermid = TRUE){
#check if data is given
if (is.null(x) == T){  # if not create dataset
x <- sdt.data()
} else {
x = x
}
dat <- tibble::tibble(tot.hits = x$hits, tot.miss = x$miss, tot.fa = x$falarm, tot.corRej = x$corRej)
dat <- dplyr::mutate(dat, hit.rate1 = (tot.hits / (tot.hits + tot.miss)))
dat <- dplyr::mutate(dat, fa.rate1 = (tot.fa / (tot.fa + tot.corRej)))
dat <- dplyr::mutate(dat, miss.rate = (tot.miss / (tot.hits + tot.miss)))
dat <- dplyr::mutate(dat, corRej.rate = (tot.corRej / (tot.fa + tot.corRej)))
#recalculate HIT rate  == 1 | == 0
dat$hit.rate <- 0
for (i in 1:length(dat$hit.rate1)) {
if (dat$hit.rate1[i] == 1) {
dat$hit.rate[i] <- (1 - 1 / (2 * (dat$tot.hits[i] + dat$tot.miss[i])))
} else if (dat$hit.rate1[i] == 0) {
dat$hit.rate[i] <- (0 + 1 / (2 * (dat$tot.hits[i] + dat$tot.miss[i])))
} else {
dat$hit.rate[i] = dat$hit.rate1[i]
}
}
#recalculate False Alarm rate  == 1 | == 0
dat$fa.rate <- 0
for (i in 1:length(dat$fa.rate1)) {
if (dat$fa.rate1[i] == 1) {
dat$fa.rate[i] <- (1 - 1 / (2 * (dat$tot.fa[i] + dat$tot.corRej[i])))
} else if (dat$fa.rate1[i] == 0) {
dat$fa.rate[i] <- (0 + 1 / (2 * (dat$tot.fa[i] + dat$tot.corRej[i])))
} else {
dat$fa.rate[i] = dat$fa.rate1[i]
}
}
#remove or retain intermediate columns
if (rm.intermid == TRUE){
dat$hit.rate1 <- NULL
dat$fa.rate1 <- NULL
print('The intermediate columns before checking for 100% or 0% accuracy or false alarms have been removed')
} else {
print('The intermediate columns before checking for 100% or 0% accuracy or false alarms have been retained and are called *hit.rate1* and *fa.rate1*')
}
print(paste("This experiment has a total number of targets:",
(dat$tot.hits[1]+dat$tot.miss[1]),
"and a total number of lures:",
(dat$tot.fa[1]+dat$tot.corRej[1])))
# Transformation to z-scores for d-prime and bias calculation
dat<- dplyr::mutate(dat, zHR = stats::qnorm(hit.rate))
dat<-dplyr::mutate(dat, zFA = stats::qnorm(fa.rate))
dat<- dplyr::mutate(dat,dPrime = (zHR - zFA))
dat <- dplyr::mutate(dat,Bias = (-0.5 * (zHR + zFA)))
avg.dprime <- mean(dat$dPrime)
sd.dprime <- stats::sd(dat$dPrime)
avg.bias <- mean(dat$Bias)
sd.bias <- stats::sd(dat$Bias)
sdt.stat <- data.frame(avg.dprime, sd.dprime, avg.bias, sd.bias)
print(paste("The average d Prime (d') score for this example is: ",
round(avg.dprime, digits = 2), "(SD=",
round(sd.dprime, digits = 2),") and the average Criterion (c) is at: ",
round(avg.bias, digits = 2), " (SD=",
round(sd.bias, digits = 2), ")."))
# Visualise the distributions of d'Prime and Bias
#
boxes <- data.frame(tidyr::gather(dat, 'Statistic', 'value', c(dPrime, Bias)))
graphics::boxplot(boxes$value ~ boxes$Statistic, col = c('salmon', 'turquoise3'),
main = 'Distributions of d\' and Bias(c)', outcol = "slateblue3")
box.plot <- grDevices::recordPlot()
rm(boxes)
sequence <- seq(-5, 10, length = 1000)
# Density Curve
# get normal probability density functions
dFAR <- stats::dnorm(sequence,mean=0,sd=1)
dHR <- stats::dnorm(sequence,mean=avg.dprime,sd=sd.dprime) # sd=1 for equal variance SD
# draw the density function + line for criterion
graphics::plot(sequence, dFAR, type = "l", col = 'turquoise3', xlab = "", ylab = "",
ylim = c(0, .5), lwd = 2, main = 'Density distribution for signal and noise') # FAR distribution
graphics::par(new = T)
graphics::plot(sequence, dHR, type = "l", col = 'salmon', axes = F, xlab = "x",
ylab = "Normal probability density function", ylim = c(0, .5), lwd = 2) # HR distribution
graphics::abline(v = avg.bias, lty = 3, lwd = 3) # dotted line for criterion
graphics::legend("topright", legend = c("Noise", "Signal", 'Criterion'), fill = c('turquoise3', 'salmon', 'black'), lty = c(1,1,3))
graphics::par(new = F)
dens <- grDevices::recordPlot()
# ROC curve
# get response probabilities for each distribution
pFAR <- 1 - stats::pnorm(sequence, mean = 0, sd = 1)
pHR <- 1 - stats::pnorm(sequence, mean = avg.dprime, sd = sd.dprime)
# get response probabilities at criterion -
pFAR.crit <- 1 - stats::pnorm(avg.bias, mean =0, sd = 1)
pHR.crit <- 1 - stats::pnorm(avg.bias, mean = avg.dprime, sd = sd.dprime)
# draw the ROC curve & dot for criterion & the chance line
graphics::plot(pFAR, pHR, type = "l", col = 'turquoise', xlim = c(0, 1), ylim = c(0, 1), xlab = "", ylab = "")
graphics::par(new = T)
graphics::plot(pFAR.crit, pHR.crit, col = 'salmon', pch = 19, xlim = c(0, 1), ylim = c(0, 1),
axes = F, xlab = "FA Rate", ylab = "Hit Rate")
graphics::abline(a = 0, b = 1,lty = 3)
graphics::par(new=F)
roc.curve <- grDevices::recordPlot()
# AUC calculation, imports flux::auc
AUC <- round(flux::auc(x = pFAR, y = pHR, thresh = 0.001), digits = 2)
print(paste('The Area Under the Curve for a sample with a mean d\'Prime of ',
round(avg.dprime, digits = 2), ' is: ',
AUC))
params <- list('statistics' = sdt.stat, 'boxes' = box.plot, 'Density' = dens, 'ROC' = roc.curve,'AUC' = AUC, 'data' = dat)
return(params)
}
rate.statistics(H,M,C,FA, x=data)
#' Complete Signal detection analysis for one group
#'
#' Calculates rate statistics, signal detection statistics - d' and c, and auc. Produces plots for visualisation.
#'
#'@details
#'     Calculates the hit rate, false alarm rate, Miss rate and Correct rejection rate,
#'     as well as the d'Prime and Bias (c). Recalculates Hit Rates and False Alarm Rates that are 1 or 0
#'     to allow d'Prime and Bias calculation. Prints the D'Prime, Bias (mean and SD), an ROC curve and a AUC
#'     calculation (AUC calculation depends on \code{\link[flux]{auc}}). The defaults of the functions are set
#'     to the dataset created by \code{\link{sdt.data}}. If function is run without any imput, it will use
#'     \code{\link{sdt.data}}'s DEFAULT inputs to generate a dataset. If you have generated a data set through
#'     \code{\link{sdt.data}} then the only requirement is to specify the dataset i.e. rate.statistics(x=DATA).
#'
#'
#' @param hits column containing total hits per person
#' @param miss column containing total misses per person
#' @param CorRej column containing total correct rejections per person
#' @param falarm column containing total dalse alarms per person
#' @param rm.intermid  TRUE/FALSE (default = TRUE) removes
#'     the intermediate columns created for the calculation of the Hit rate and False Alarm rate,
#'     which are created for the recalculation of Hit rates and False alarm rates that are equal to 1 or 0
#'
#' @param x  Data frame - Must be in summary form (i.e. each row is a participant
#'     with columns: total hits per person, total false alarms per person, total correct rejections and
#'     total misses)
#'
#' @return
#'     \item{statistics}{A simple table containing the average d'prime and bias as well as their sd}
#'     \item{boxes}{Boxplots depicting the distribution of the d'prime and bias}
#'     \item{Density}{The density distributions for signal and noise}
#'     \item{ROC}{An ROC curve for both groups, including a dot for the position of the criterion}
#'     \item{AUC}{Area under the curve}
#'     \item{data}{Data frame with transformations and calculations}
#'
#'
#' @examples
#'     rate.statistics()
#'
#'     data <- sdt.data(50,50,0.35,0.11)
#'     result <- rate.statistics(x=data,rm.intermid = TRUE)
#'     result$ROC
#'\dontrun{
#'     rate.statistics(hits = HIT, miss = Miss, CorRej = CR,
#'                 falarm = FA, sdt = my.dataset, rm.intermid = FALSE)
#'}
rate.stat <- function(hits = hits, miss = miss, CorRej = CorRej, falarm = falarm, x = NULL, rm.intermid = TRUE){
#check if data is given
if (is.null(x) == T){  # if not create dataset
x <- sdt.data()
} else {
x = x
}
dat <- tibble::tibble(tot.hits = x$hits, tot.miss = x$miss, tot.fa = x$falarm, tot.corRej = x$CorRej)
dat <- dplyr::mutate(dat, hit.rate1 = (tot.hits / (tot.hits + tot.miss)))
dat <- dplyr::mutate(dat, fa.rate1 = (tot.fa / (tot.fa + tot.corRej)))
dat <- dplyr::mutate(dat, miss.rate = (tot.miss / (tot.hits + tot.miss)))
dat <- dplyr::mutate(dat, corRej.rate = (tot.corRej / (tot.fa + tot.corRej)))
#recalculate HIT rate  == 1 | == 0
dat$hit.rate <- 0
for (i in 1:length(dat$hit.rate1)) {
if (dat$hit.rate1[i] == 1) {
dat$hit.rate[i] <- (1 - 1 / (2 * (dat$tot.hits[i] + dat$tot.miss[i])))
} else if (dat$hit.rate1[i] == 0) {
dat$hit.rate[i] <- (0 + 1 / (2 * (dat$tot.hits[i] + dat$tot.miss[i])))
} else {
dat$hit.rate[i] = dat$hit.rate1[i]
}
}
#recalculate False Alarm rate  == 1 | == 0
dat$fa.rate <- 0
for (i in 1:length(dat$fa.rate1)) {
if (dat$fa.rate1[i] == 1) {
dat$fa.rate[i] <- (1 - 1 / (2 * (dat$tot.fa[i] + dat$tot.corRej[i])))
} else if (dat$fa.rate1[i] == 0) {
dat$fa.rate[i] <- (0 + 1 / (2 * (dat$tot.fa[i] + dat$tot.corRej[i])))
} else {
dat$fa.rate[i] = dat$fa.rate1[i]
}
}
#remove or retain intermediate columns
if (rm.intermid == TRUE){
dat$hit.rate1 <- NULL
dat$fa.rate1 <- NULL
print('The intermediate columns before checking for 100% or 0% accuracy or false alarms have been removed')
} else {
print('The intermediate columns before checking for 100% or 0% accuracy or false alarms have been retained and are called *hit.rate1* and *fa.rate1*')
}
print(paste("This experiment has a total number of targets:",
(dat$tot.hits[1]+dat$tot.miss[1]),
"and a total number of lures:",
(dat$tot.fa[1]+dat$tot.corRej[1])))
# Transformation to z-scores for d-prime and bias calculation
dat<- dplyr::mutate(dat, zHR = stats::qnorm(hit.rate))
dat<-dplyr::mutate(dat, zFA = stats::qnorm(fa.rate))
dat<- dplyr::mutate(dat,dPrime = (zHR - zFA))
dat <- dplyr::mutate(dat,Bias = (-0.5 * (zHR + zFA)))
avg.dprime <- mean(dat$dPrime)
sd.dprime <- stats::sd(dat$dPrime)
avg.bias <- mean(dat$Bias)
sd.bias <- stats::sd(dat$Bias)
sdt.stat <- data.frame(avg.dprime, sd.dprime, avg.bias, sd.bias)
print(paste("The average d Prime (d') score for this example is: ",
round(avg.dprime, digits = 2), "(SD=",
round(sd.dprime, digits = 2),") and the average Criterion (c) is at: ",
round(avg.bias, digits = 2), " (SD=",
round(sd.bias, digits = 2), ")."))
# Visualise the distributions of d'Prime and Bias
#
boxes <- data.frame(tidyr::gather(dat, 'Statistic', 'value', c(dPrime, Bias)))
graphics::boxplot(boxes$value ~ boxes$Statistic, col = c('salmon', 'turquoise3'),
main = 'Distributions of d\' and Bias(c)', outcol = "slateblue3")
box.plot <- grDevices::recordPlot()
rm(boxes)
sequence <- seq(-5, 10, length = 1000)
# Density Curve
# get normal probability density functions
dFAR <- stats::dnorm(sequence,mean=0,sd=1)
dHR <- stats::dnorm(sequence,mean=avg.dprime,sd=sd.dprime) # sd=1 for equal variance SD
# draw the density function + line for criterion
graphics::plot(sequence, dFAR, type = "l", col = 'turquoise3', xlab = "", ylab = "",
ylim = c(0, .5), lwd = 2, main = 'Density distribution for signal and noise') # FAR distribution
graphics::par(new = T)
graphics::plot(sequence, dHR, type = "l", col = 'salmon', axes = F, xlab = "x",
ylab = "Normal probability density function", ylim = c(0, .5), lwd = 2) # HR distribution
graphics::abline(v = avg.bias, lty = 3, lwd = 3) # dotted line for criterion
graphics::legend("topright", legend = c("Noise", "Signal", 'Criterion'), fill = c('turquoise3', 'salmon', 'black'), lty = c(1,1,3))
graphics::par(new = F)
dens <- grDevices::recordPlot()
# ROC curve
# get response probabilities for each distribution
pFAR <- 1 - stats::pnorm(sequence, mean = 0, sd = 1)
pHR <- 1 - stats::pnorm(sequence, mean = avg.dprime, sd = sd.dprime)
# get response probabilities at criterion -
pFAR.crit <- 1 - stats::pnorm(avg.bias, mean =0, sd = 1)
pHR.crit <- 1 - stats::pnorm(avg.bias, mean = avg.dprime, sd = sd.dprime)
# draw the ROC curve & dot for criterion & the chance line
graphics::plot(pFAR, pHR, type = "l", col = 'turquoise', xlim = c(0, 1), ylim = c(0, 1), xlab = "", ylab = "")
graphics::par(new = T)
graphics::plot(pFAR.crit, pHR.crit, col = 'salmon', pch = 19, xlim = c(0, 1), ylim = c(0, 1),
axes = F, xlab = "FA Rate", ylab = "Hit Rate")
graphics::abline(a = 0, b = 1,lty = 3)
graphics::par(new=F)
roc.curve <- grDevices::recordPlot()
# AUC calculation, imports flux::auc
AUC <- round(flux::auc(x = pFAR, y = pHR, thresh = 0.001), digits = 2)
print(paste('The Area Under the Curve for a sample with a mean d\'Prime of ',
round(avg.dprime, digits = 2), ' is: ',
AUC))
params <- list('statistics' = sdt.stat, 'boxes' = box.plot, 'Density' = dens, 'ROC' = roc.curve,'AUC' = AUC, 'data' = dat)
return(params)
}
rate.stat(H,M,C,FA, x=data)
#' Complete Signal detection analysis for one group
#'
#' Calculates rate statistics, signal detection statistics - d' and c, and auc. Produces plots for visualisation.
#'
#'@details
#'     Calculates the hit rate, false alarm rate, Miss rate and Correct rejection rate,
#'     as well as the d'Prime and Bias (c). Recalculates Hit Rates and False Alarm Rates that are 1 or 0
#'     to allow d'Prime and Bias calculation. Prints the D'Prime, Bias (mean and SD), an ROC curve and a AUC
#'     calculation (AUC calculation depends on \code{\link[flux]{auc}}). The defaults of the functions are set
#'     to the dataset created by \code{\link{sdt.data}}. If function is run without any imput, it will use
#'     \code{\link{sdt.data}}'s DEFAULT inputs to generate a dataset. If you have generated a data set through
#'     \code{\link{sdt.data}} then the only requirement is to specify the dataset i.e. rate.statistics(x=DATA).
#'
#'
#' @param hits column containing total hits per person
#' @param miss column containing total misses per person
#' @param CorRej column containing total correct rejections per person
#' @param falarm column containing total dalse alarms per person
#' @param rm.intermid  TRUE/FALSE (default = TRUE) removes
#'     the intermediate columns created for the calculation of the Hit rate and False Alarm rate,
#'     which are created for the recalculation of Hit rates and False alarm rates that are equal to 1 or 0
#'
#' @param x  Data frame - Must be in summary form (i.e. each row is a participant
#'     with columns: total hits per person, total false alarms per person, total correct rejections and
#'     total misses)
#'
#' @return
#'     \item{statistics}{A simple table containing the average d'prime and bias as well as their sd}
#'     \item{boxes}{Boxplots depicting the distribution of the d'prime and bias}
#'     \item{Density}{The density distributions for signal and noise}
#'     \item{ROC}{An ROC curve for both groups, including a dot for the position of the criterion}
#'     \item{AUC}{Area under the curve}
#'     \item{data}{Data frame with transformations and calculations}
#'
#'
#' @examples
#'     rate.statistics()
#'
#'     data <- sdt.data(50,50,0.35,0.11)
#'     result <- rate.statistics(x=data,rm.intermid = TRUE)
#'     result$ROC
#'\dontrun{
#'     rate.statistics(hits = HIT, miss = Miss, CorRej = CR,
#'                 falarm = FA, sdt = my.dataset, rm.intermid = FALSE)
#'}
rate.stat <- function(hits = hits, miss = miss, CorRej = CorRej, falarm = falarm, x = NULL, rm.intermid = TRUE){
#check if data is given
if (is.null(x) == T){  # if not create dataset
x <- sdt.data()
} else {
x = x
}
dat <- data.frame(tot.hits = x[[hits]], tot.miss = x[[miss]], tot.fa = x[[falarm]], tot.corRej = x[[CorRej]])
dat <- dplyr::mutate(dat, hit.rate1 = (tot.hits / (tot.hits + tot.miss)))
dat <- dplyr::mutate(dat, fa.rate1 = (tot.fa / (tot.fa + tot.corRej)))
dat <- dplyr::mutate(dat, miss.rate = (tot.miss / (tot.hits + tot.miss)))
dat <- dplyr::mutate(dat, corRej.rate = (tot.corRej / (tot.fa + tot.corRej)))
#recalculate HIT rate  == 1 | == 0
dat$hit.rate <- 0
for (i in 1:length(dat$hit.rate1)) {
if (dat$hit.rate1[i] == 1) {
dat$hit.rate[i] <- (1 - 1 / (2 * (dat$tot.hits[i] + dat$tot.miss[i])))
} else if (dat$hit.rate1[i] == 0) {
dat$hit.rate[i] <- (0 + 1 / (2 * (dat$tot.hits[i] + dat$tot.miss[i])))
} else {
dat$hit.rate[i] = dat$hit.rate1[i]
}
}
#recalculate False Alarm rate  == 1 | == 0
dat$fa.rate <- 0
for (i in 1:length(dat$fa.rate1)) {
if (dat$fa.rate1[i] == 1) {
dat$fa.rate[i] <- (1 - 1 / (2 * (dat$tot.fa[i] + dat$tot.corRej[i])))
} else if (dat$fa.rate1[i] == 0) {
dat$fa.rate[i] <- (0 + 1 / (2 * (dat$tot.fa[i] + dat$tot.corRej[i])))
} else {
dat$fa.rate[i] = dat$fa.rate1[i]
}
}
#remove or retain intermediate columns
if (rm.intermid == TRUE){
dat$hit.rate1 <- NULL
dat$fa.rate1 <- NULL
print('The intermediate columns before checking for 100% or 0% accuracy or false alarms have been removed')
} else {
print('The intermediate columns before checking for 100% or 0% accuracy or false alarms have been retained and are called *hit.rate1* and *fa.rate1*')
}
print(paste("This experiment has a total number of targets:",
(dat$tot.hits[1]+dat$tot.miss[1]),
"and a total number of lures:",
(dat$tot.fa[1]+dat$tot.corRej[1])))
# Transformation to z-scores for d-prime and bias calculation
dat<- dplyr::mutate(dat, zHR = stats::qnorm(hit.rate))
dat<-dplyr::mutate(dat, zFA = stats::qnorm(fa.rate))
dat<- dplyr::mutate(dat,dPrime = (zHR - zFA))
dat <- dplyr::mutate(dat,Bias = (-0.5 * (zHR + zFA)))
avg.dprime <- mean(dat$dPrime)
sd.dprime <- stats::sd(dat$dPrime)
avg.bias <- mean(dat$Bias)
sd.bias <- stats::sd(dat$Bias)
sdt.stat <- data.frame(avg.dprime, sd.dprime, avg.bias, sd.bias)
print(paste("The average d Prime (d') score for this example is: ",
round(avg.dprime, digits = 2), "(SD=",
round(sd.dprime, digits = 2),") and the average Criterion (c) is at: ",
round(avg.bias, digits = 2), " (SD=",
round(sd.bias, digits = 2), ")."))
# Visualise the distributions of d'Prime and Bias
#
boxes <- data.frame(tidyr::gather(dat, 'Statistic', 'value', c(dPrime, Bias)))
graphics::boxplot(boxes$value ~ boxes$Statistic, col = c('salmon', 'turquoise3'),
main = 'Distributions of d\' and Bias(c)', outcol = "slateblue3")
box.plot <- grDevices::recordPlot()
rm(boxes)
sequence <- seq(-5, 10, length = 1000)
# Density Curve
# get normal probability density functions
dFAR <- stats::dnorm(sequence,mean=0,sd=1)
dHR <- stats::dnorm(sequence,mean=avg.dprime,sd=sd.dprime) # sd=1 for equal variance SD
# draw the density function + line for criterion
graphics::plot(sequence, dFAR, type = "l", col = 'turquoise3', xlab = "", ylab = "",
ylim = c(0, .5), lwd = 2, main = 'Density distribution for signal and noise') # FAR distribution
graphics::par(new = T)
graphics::plot(sequence, dHR, type = "l", col = 'salmon', axes = F, xlab = "x",
ylab = "Normal probability density function", ylim = c(0, .5), lwd = 2) # HR distribution
graphics::abline(v = avg.bias, lty = 3, lwd = 3) # dotted line for criterion
graphics::legend("topright", legend = c("Noise", "Signal", 'Criterion'), fill = c('turquoise3', 'salmon', 'black'), lty = c(1,1,3))
graphics::par(new = F)
dens <- grDevices::recordPlot()
# ROC curve
# get response probabilities for each distribution
pFAR <- 1 - stats::pnorm(sequence, mean = 0, sd = 1)
pHR <- 1 - stats::pnorm(sequence, mean = avg.dprime, sd = sd.dprime)
# get response probabilities at criterion -
pFAR.crit <- 1 - stats::pnorm(avg.bias, mean =0, sd = 1)
pHR.crit <- 1 - stats::pnorm(avg.bias, mean = avg.dprime, sd = sd.dprime)
# draw the ROC curve & dot for criterion & the chance line
graphics::plot(pFAR, pHR, type = "l", col = 'turquoise', xlim = c(0, 1), ylim = c(0, 1), xlab = "", ylab = "")
graphics::par(new = T)
graphics::plot(pFAR.crit, pHR.crit, col = 'salmon', pch = 19, xlim = c(0, 1), ylim = c(0, 1),
axes = F, xlab = "FA Rate", ylab = "Hit Rate")
graphics::abline(a = 0, b = 1,lty = 3)
graphics::par(new=F)
roc.curve <- grDevices::recordPlot()
# AUC calculation, imports flux::auc
AUC <- round(flux::auc(x = pFAR, y = pHR, thresh = 0.001), digits = 2)
print(paste('The Area Under the Curve for a sample with a mean d\'Prime of ',
round(avg.dprime, digits = 2), ' is: ',
AUC))
params <- list('statistics' = sdt.stat, 'boxes' = box.plot, 'Density' = dens, 'ROC' = roc.curve,'AUC' = AUC, 'data' = dat)
return(params)
}
rate.stat(H,M,C,FA, x=data)
rate.stat('H','M','C','FA', x=data)
shiny::runApp('D:/rrr')
runApp('D:/rrr')
runApp('D:/rrr')
runApp('D:/rrr')
runApp('D:/rrr')
runApp('D:/rrr')
runApp('D:/rrr')
install.packages(c("backports", "broom", "callr", "clipr", "colorspace", "curl", "dbplyr", "DescTools", "digest", "dplyr", "edfReader", "evaluate", "expm", "forcats", "fs", "ggplot2", "gtable", "haven", "highr", "httpuv", "httr", "jsonlite", "knitr", "later", "lazyeval", "lme4", "markdown", "modelr", "pillar", "processx", "ps", "rcmdcheck", "RcppEigen", "readr", "readxl", "reprex", "rmarkdown", "rstudioapi", "rvest", "shiny", "stringr", "tibble", "tinytex", "xfun", "xtable"))
install.packages("installr");
install.packages(c("backports", "broom", "callr", "clipr", "colorspace", "curl", "dbplyr", "DescTools", "digest", "dplyr", "edfReader", "evaluate", "expm", "forcats", "fs", "ggplot2", "gtable", "haven", "highr", "httpuv", "httr", "jsonlite", "knitr", "later", "lazyeval", "lme4", "markdown", "modelr", "pillar", "processx", "ps", "rcmdcheck", "RcppEigen", "readr", "readxl", "reprex", "rmarkdown", "rstudioapi", "rvest", "shiny", "stringr", "tibble", "tinytex", "xfun", "xtable"))
installr::updateR()
library(tidyverse) # this is a wraper that loads additional packages
setwd("D:/Githug/TeachingR")
setwd("~/")
setwd("D:/Githug/TeachingR")
exports <- read_csv('exports_by_industry.csv')
View(exports)
View(exports)
setwd("D:/Githug/TeachingR/teaching_R/R for Complete Beginners")
exports_2sheet <- read_excel('exports_by_industry_2sheets.xlsx', sheet = 'Sheet 2')
library(readxl) # helps us read in excel files
exports_2sheet <- read_excel('exports_by_industry_2sheets.xlsx', sheet = 'Sheet 2')
exports_2sheet <- read_excel('exports_by_industry_2sheets.xlsx', sheet = 'Sheet2')
exports_2sheet <- read_excel('exports_by_industry_2sheets.xlsx', sheet = 'Sheet1')
View(exports_2sheet)
exports_1 <- select(exports, DateCode, Value, `Industry Sector (SIC 07)`, `Export Destination`)
View(exports_1)
exports1_2010 <- filter(exports_1, DateCode == 2017)
#we want only 2017
exports1_2017 <- filter(exports_1, DateCode == 2017)
rm(exports1_2010)
View(exports1_2017)
exports1_2017_nototal <- filter(exports_1, `Industry Sector (SIC07)` != 'Total')
exports1_2017_nototal <- filter(exports_1, `Industry Sector (SIC 07)` != 'Total')
exports1_2017_nototal <- filter(exports1_2017, `Industry Sector (SIC 07)` != 'Total')
exports1_nototal <- filter(exports_1, `Industry Sector (SIC 07)` != 'Total')
View(exports1_nototal)
exports1_billions <- mutate(exports1_2017_nototal, value_billions = Value/1000)
View(exports1_billions)
exports1_billions_destinations <- group_by(exports1_billions, `Export Destination`)
View(exports1_billions_destinations) # notice no actual change
glimpse(exports1_billions_destinations) # notice the groups
exports_countries_summarised <- sumamrise(exports1_billions_destinations, total_exp_destination = sum(value_billions))
exports_countries_summarised <- summarise(exports1_billions_destinations, total_exp_destination = sum(value_billions))
View(exports_countries_summarised)
exports1_wide <- spread(exports1_billions, key = `Export Destination`, value = value_billions)
View(exports1_wide)
exports1_wide <- spread(exports1_2017_nototal, key = `Export Destination`, value = Value)
View(exports1_wide)
exports1_long <- gather(exports1_wide, key = 'export_destiantion', value = 'Value', c(3:7))#or c(EU:Total) or list all
View(exports1_long)
ggplot(exports1_long, aes(x = export_destination, y = Value)) + geom_col()
exports1_long <- gather(exports1_wide, key = 'export_destination', value = 'Value', c(3:7))#or c(EU:Total) or list all
ggplot(exports1_long, aes(x = export_destination, y = Value)) + geom_col()
ggplot(exports1_long, aes(x = export_destination, y = Value)) +
geom_violin() +
geom_point(aes(group = `Industry Sector (SIC 07)`, colour = `Industry Sector (SIC 07)`))
ggplot(exports1_long, aes(x = `Industry Sector (SIC 07)`, y = Value)) +
geom_violin() +
geom_point(aes(group = export_destination, colour = `Industry Sector (SIC 07)`))
ggplot(exports1_long, aes(x = `Industry Sector (SIC 07)`, y = Value)) +
geom_violin() +
geom_point(aes(group = export_destination, colour = export_destination))
ggplot(exports1_long, aes(x = `Industry Sector (SIC 07)`, y = Value)) +
geom_col() +
geom_point(aes(group = export_destination, colour = export_destination))
ggplot(exports1_long, aes(x = `Industry Sector (SIC 07)`, y = Value)) +
geom_col() +
geom_point(aes(group = export_destination, colour = export_destination)) +
coord_flip()
ggplot(exports_1, aes(DateCode, Value)) +
geom_point(aes(color=`Export Destination`))
ggplot(exports_1, aes(DateCode, Value, group=`Export Destination`)) +
geom_point(aes(color=`Export Destination`))
ggplot(exports_1, aes(DateCode, Value, group=`Export Destination`)) +
geom_point()
ggplot(exports_1, aes(DateCode, Value, color=`Export Destination`)) +
geom_point()
ggplot(exports_1, aes(DateCode, Value)) +
geom_point()
ggplot(exports_1, aes(DateCode, Value, group = `Export Destination`, colour = `Export Destination`)) +
geom_line()
ggplot(exports_1, aes(DateCode, Value, colour = `Export Destination`)) +
geom_line()
ggplot(exports_1, aes(DateCode, Value, )) +
geom_line()
ggplot(exports_1, aes(DateCode, Value)) +
geom_line(group = `Export Destination`)
ggplot(exports_1, aes(DateCode, Value)) +
geom_line(aes(group = `Export Destination`))
ggplot(exports_1, aes(DateCode, Value)) +
geom_line(aes(color = `Export Destination`))
exports_line <- filter(exports_1, `Industry Sector (SIC 07)` = 'Total')
exports_line <- filter(exports_1, `Industry Sector (SIC 07)` == 'Total')
ggplot(exports_line, aes(DateCode, Value)) +
geom_line(aes(color = `Export Destination`))
